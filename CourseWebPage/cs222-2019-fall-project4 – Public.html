<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0067)https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4 -->
<html xmlns="http://www.w3.org/1999/xhtml" class="gr__grape_ics_uci_edu"><link type="text/css" id="dark-mode" rel="stylesheet" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4"><style type="text/css" id="dark-mode-custom-style"></style><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>
      cs222-2019-fall-project4 – Public
    </title>
      
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!--[if IE]><script type="text/javascript">
      if (/^#__msie303:/.test(window.location.hash))
        window.location.replace(window.location.hash.replace(/^#__msie303:/, '#'));
    </script><![endif]-->
        <link rel="search" href="https://grape.ics.uci.edu/wiki/public/search">
        <link rel="help" href="https://grape.ics.uci.edu/wiki/public/wiki/TracGuide">
        <link rel="alternate" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4?format=txt" type="text/x-trac-wiki" title="Plain Text">
        <link rel="tracwysiwyg.base" href="https://grape.ics.uci.edu/wiki/public">
        <link rel="start" href="https://grape.ics.uci.edu/wiki/public/wiki">
        <link rel="stylesheet" href="./cs222-2019-fall-project4 – Public_files/trac.css" type="text/css"><link rel="stylesheet" href="./cs222-2019-fall-project4 – Public_files/wiki.css" type="text/css"><link rel="stylesheet" href="./cs222-2019-fall-project4 – Public_files/wysiwyg.css" type="text/css">
        <link rel="tracwysiwyg.stylesheet" href="./cs222-2019-fall-project4 – Public_files/trac.css"><link rel="tracwysiwyg.stylesheet" href="https://grape.ics.uci.edu/wiki/public/chrome/tracwysiwyg/editor.css">
        <link rel="shortcut icon" href="https://grape.ics.uci.edu/wiki/public/chrome/site/favicon.ico" type="image/x-icon">
        <link rel="icon" href="https://grape.ics.uci.edu/wiki/public/chrome/site/favicon.ico" type="image/x-icon">
    
    <script type="text/javascript">
      var _tracwysiwyg={};
    </script>
      <script type="text/javascript" charset="utf-8" src="./cs222-2019-fall-project4 – Public_files/jquery.js.download"></script>
      <script type="text/javascript" charset="utf-8" src="./cs222-2019-fall-project4 – Public_files/babel.js.download"></script>
      <script type="text/javascript" charset="utf-8" src="./cs222-2019-fall-project4 – Public_files/trac.js.download"></script>
      <script type="text/javascript" charset="utf-8" src="./cs222-2019-fall-project4 – Public_files/search.js.download"></script>
      <script type="text/javascript" charset="utf-8" src="./cs222-2019-fall-project4 – Public_files/folding.js.download"></script>
      <script type="text/javascript" charset="utf-8" src="./cs222-2019-fall-project4 – Public_files/wysiwyg.js.download"></script>
    <script type="text/javascript">
      jQuery("#trac-noscript").remove();
      jQuery(document).ready(function($) {
        $(".trac-autofocus").focus();
        $(".trac-target-new").attr("target", "_blank");
        setTimeout(function() { $(".trac-scroll").scrollToTop() }, 1);
        $(".trac-disable-on-submit").disableOnSubmit();
      });
    </script>
    <script type="text/javascript">
      jQuery(document).ready(function($) {
        $("#content").find("h1,h2,h3,h4,h5,h6").addAnchor(_("Link to this section"));
        $("#content").find(".wikianchor").each(function() {
          $(this).addAnchor(babel.format(_("Link to #%(id)s"), {id: $(this).attr('id')}));
        });
        $(".foldable").enableFolding(true, true);
      });
    </script>
  </head>
  <body data-gr-c-s-loaded="true">
    <div id="banner">
      <div id="header">
        <a id="logo" href="http://www.ics.uci.edu/"><img src="./cs222-2019-fall-project4 – Public_files/ics.jpg" alt="ICS Logo" height="67" width="128"></a>
      </div>
      <form id="search" action="https://grape.ics.uci.edu/wiki/public/search" method="get">
      </form>
      <div id="metanav" class="nav">
    <ul>
      <li class="first"><a href="https://grape.ics.uci.edu/wiki/public/login">Login</a></li><li><a href="https://grape.ics.uci.edu/wiki/public/prefs">Preferences</a></li><li class="last"><a href="https://grape.ics.uci.edu/wiki/public/about">About Trac</a></li>
    </ul>
  </div>
    </div>
    <div id="mainnav" class="nav">
  </div>
    <div id="main">
      <div id="pagepath" class="noprint">
  <a class="pathentry first" title="View WikiStart" href="https://grape.ics.uci.edu/wiki/public/wiki">wiki:</a><a class="pathentry" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4" title="View cs222-2019-fall-project4">cs222-2019-fall-project4</a>
</div>
      <div id="ctxtnav" class="nav">
        <h2>Context Navigation</h2>
        <ul>
          <li class="first"><a href="https://grape.ics.uci.edu/wiki/public/wiki/WikiStart">Start Page</a></li><li><a href="https://grape.ics.uci.edu/wiki/public/wiki/TitleIndex">Index</a></li><li class="last"><a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4?action=history">History</a></li>
        </ul>
        <hr>
      </div>
    <div id="content" class="wiki">
      <div class="wikipage searchable">
        
          <div id="wikipage" class="trac-content"><p>
</p><div class="wiki-toc">
<ol>
  <li>
    <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#Project4:ImplementingaQueryEnginewiththeExtensionoftheRelationManager">Project 4: Implementing a Query Engine with the Extension of the …</a>
    <ol>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#Introduction">Introduction</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#CodeBase">CodeBase</a>
      </li>
    </ol>
  </li>
  <li>
    <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#Part4.1:RelationManagerExtensions">Part 4.1: RelationManager Extensions</a>
    <ol>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RelationManager">RelationManager</a>
        <ol>
          <li>
            <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RCcreateIndexconststringtableNameconststringattributeName">RC createIndex(const string &amp;tableName, const string &amp;attributeName)</a>
          </li>
          <li>
            <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RCdestroyIndexconststringtableNameconststringattributeName">RC destroyIndex(const string &amp;tableName, const string &amp;attributeName)</a>
          </li>
          <li>
            <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RCindexScanconststringtableNameconststringattributeNameconstvoidlowKeyconstvoidhighKeyboollowKeyInclusiveboolhighKeyInclusiveRM_IndexScanIteratorrm_IndexScanIterator">RC indexScan(const string &amp;tableName, const string &amp;attributeName, …</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RM_IndexScanIterator">RM_IndexScanIterator</a>
        <ol>
          <li>
            <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RCgetNextEntryRIDridvoidkey">RC getNextEntry(RID &amp;rid, void *key)</a>
          </li>
          <li>
            <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RCclose">RC close()</a>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#Part4.2:QueryEngine">Part 4.2: Query Engine</a>
    <ol>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#IteratorInterface">Iterator Interface</a>
        <ol>
          <li>
            <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#virtualRCgetNextTuplevoiddata">virtual RC getNextTuple(void *data)</a>
          </li>
          <li>
            <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#virtualvoidgetAttributesvectorAttributeattrs">virtual void getAttributes(vector&lt;Attribute&gt; &amp;attrs)</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#FilterInterface">Filter Interface</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#ProjectInterface">Project Interface</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#BlockNested-LoopJoinInterface">Block Nested-Loop Join Interface</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#IndexNested-LoopJoinInterface">Index Nested-Loop Join Interface</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#GraceHashJoinInterface">Grace Hash Join Interface</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#AggregateInterface">Aggregate Interface</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#ImportantNote">Important Note</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#AnExample">An Example</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#CommandLineInterfaceInterpreter">Command Line Interface Interpreter</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#Appendix">Appendix</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#Testing">Testing</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#SubmissionInstructions">Submission Instructions</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#GradingRubrics">Grading Rubrics</a>
      </li>
      <li>
        <a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#QA">Q &amp; A</a>
      </li>
    </ol>
  </li>
</ol>
</div><p>
</p>
<h1 id="Project4:ImplementingaQueryEnginewiththeExtensionoftheRelationManager">Project 4: Implementing a Query Engine with the Extension of the Relation Manager<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#Project4:ImplementingaQueryEnginewiththeExtensionoftheRelationManager" title="Link to this section"> ¶</a></h1>
<ul><li><strong> Deadline: Friday, Dec 6th, 2019 at 11:45 pm, on Github.</strong>
</li><li><strong> Full Credit: 100 points </strong>
</li><li><strong> Maximum Extra Credit: 15 points. </strong><br>
</li><li><strong> As in Projects 2 and 3, you should work with your original team member for this Project. </strong>
</li></ul><h2 id="Introduction">Introduction<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#Introduction" title="Link to this section"> ¶</a></h2>
<p>
In this project, you will first extend the RelationManager (RM) component that you implemented for project 2 so that the RM layer can orchestrate both the RecordBasedFileManager (RBF) and IndexManager (IX) layers when tuple-level operations happen, and the RM layer will also be managing the catalog information related to indices at this level. After the RM layer extension, you will implement a QueryEngine (QE) component. The QE component provides classes and methods for answering SQL queries. For simplicity, you only need to implement several basic relational operators. All operators are iterator-based. To give you a jumpstart, we've implemented two wrapper operators on top of the RM layer that provide file and index scanning. See the <a class="wiki" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#Appendix">Appendix</a> for more details.<br>
</p>
<h2 id="CodeBase">CodeBase<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#CodeBase" title="Link to this section"> ¶</a></h2>
<p>
As in previous Projects, we have provided you with a framework to implement Project 4. Please download this <a class="attachment" href="https://grape.ics.uci.edu/wiki/public/attachment/wiki/cs222-2019-fall-project4/Project4.patch" title="Attachment &#39;Project4.patch&#39; in cs222-2019-fall-project4">Project4.patch</a><a class="trac-rawlink" href="https://grape.ics.uci.edu/wiki/public/raw-attachment/wiki/cs222-2019-fall-project4/Project4.patch" title="Download">​</a> file, put it in your git repo, and apply it to your codebase with <tt>git am Project4.patch</tt>. 
</p>
<p>
OR, if the patch file does not work, you can follow <a class="wiki" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project-fetch-code-framework">these steps</a> to fetch the code framework manually. 
</p>
<p>
If you run into conflicts that you do not know how to merge, you can manually copy paste changes in files from the above repo. If needed, please come to office hour for assistance.
</p>
<p>
Then you can start Project 4:
</p>
<ul><li>Modify the "CODEROOT" variable in makefile.inc to point to the root of your codebase if necessary.
</li><li>Implement the extension of Relation Manager (RM) to coordinate data files and the associated indices of the data files. 
</li><li>Implement Query Engine (QE)
</li><li>If you think changes are necessary, please contact us first.
</li></ul><p>
<br>
</p>
<h1 id="Part4.1:RelationManagerExtensions">Part 4.1: RelationManager Extensions<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#Part4.1:RelationManagerExtensions" title="Link to this section"> ¶</a></h1>
<h2 id="RelationManager">RelationManager<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RelationManager" title="Link to this section"> ¶</a></h2>
<p>
All of the methods that you implemented for Project 2 should now be extended to coordinate data files plus any associated indices of the data files. For example, if you insert a tuple into a table using RelationManager::insertTuple(), the tuple should be inserted into the table (via the RBF layer) and each corresponding entry should be inserted into each associated index of the table (via the IX layer). Also, if you delete a table using RelationManager::deleteTable(), all associated indices should be deleted, too. This applies both to catalog entries that record what's what and to the file artifacts themselves.  The RelationManager class, in addition to enforcing the coordination semantics between data files and the indices in your existing methods, will also include the following newly-added index-related methods. These methods can all be implemented by simply delegating their work to the underlying IX layer that you built in Project 3. (This part of the project is largely a big wrapper. :-))
</p>
<pre class="wiki">class RelationManager
{
public:
  ...
    RC createIndex(const std::string &amp;tableName, const std::string &amp;attributeName);
 
    RC destroyIndex(const std::string &amp;tableName, const std::string &amp;attributeName);

    // indexScan returns an iterator to allow the caller to go through qualified entries in index
    RC indexScan(const std::string &amp;tableName,
                 const std::string &amp;attributeName,
                 const void *lowKey,
                 const void *highKey,
                 bool lowKeyInclusive,
                 bool highKeyInclusive,
                 RM_IndexScanIterator &amp;rm_IndexScanIterator);
  ...
}
</pre><h3 id="RCcreateIndexconststringtableNameconststringattributeName">RC createIndex(const string &amp;tableName, const string &amp;attributeName)<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RCcreateIndexconststringtableNameconststringattributeName" title="Link to this section"> ¶</a></h3>
<p>
This method creates an index on a given attribute of a given table.  (It should also reflect its existence in the catalogs.)
</p>
<h3 id="RCdestroyIndexconststringtableNameconststringattributeName">RC destroyIndex(const string &amp;tableName, const string &amp;attributeName)<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RCdestroyIndexconststringtableNameconststringattributeName" title="Link to this section"> ¶</a></h3>
<p>
This method destroys an index on a given attribute of a given table.  (It should also reflect its non-existence in the catalogs.)
</p>
<h3 id="RCindexScanconststringtableNameconststringattributeNameconstvoidlowKeyconstvoidhighKeyboollowKeyInclusiveboolhighKeyInclusiveRM_IndexScanIteratorrm_IndexScanIterator">RC indexScan(const string &amp;tableName, const string &amp;attributeName, const void *lowKey, const void *highKey, bool lowKeyInclusive, bool highKeyInclusive, RM_IndexScanIterator &amp;rm_IndexScanIterator)<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RCindexScanconststringtableNameconststringattributeNameconstvoidlowKeyconstvoidhighKeyboollowKeyInclusiveboolhighKeyInclusiveRM_IndexScanIteratorrm_IndexScanIterator" title="Link to this section"> ¶</a></h3>
<p>
This method should initialize a condition-based scan over the entries in the open index on the given attribute of the given table. If the scan initiation method is successful, a RM_IndexScanIterator object called rm_IndexScanIterator is returned. (Please see the RM_IndexScanIterator class below.) Once underway, by calling RM_IndexScanIterator::getNextEntry(), the iterator should produce the entries of all records whose indexed attribute key falls into the range specified by the lowKey, highKey, and inclusive flags. If lowKey is NULL, it can be interpreted as -infinity. If highKey is NULL, it can be interpreted as +infinity. The format of the parameter lowKey and highKey is the same as the format of the key in IndexManager::insertEntry(). 
</p>
<h2 id="RM_IndexScanIterator">RM_IndexScanIterator<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RM_IndexScanIterator" title="Link to this section"> ¶</a></h2>
<pre class="wiki">class RM_IndexScanIterator {
public:
    RM_IndexScanIterator() {};                     // Constructor
    ~RM_IndexScanIterator() {};                   // Destructor

    // "key" follows the same format as in IndexManager::insertEntry()
    RC getNextEntry(RID &amp;rid, void *key);  // Get next matching entry
    RC close();                                              // Terminate index scan
};
</pre><h3 id="RCgetNextEntryRIDridvoidkey">RC getNextEntry(RID &amp;rid, void *key)<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RCgetNextEntryRIDridvoidkey" title="Link to this section"> ¶</a></h3>
<p>
This method should set its output parameters rid and key to be the RID and key, respectively, of the next record in the index scan. This method should return RM_EOF if there are no index entries left satisfying the scan condition. You may assume that RM component clients will not close the corresponding open index while a scan is underway.
</p>
<h3 id="RCclose">RC close()<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#RCclose" title="Link to this section"> ¶</a></h3>
<p>
This method should terminate the index scan.
</p>
<p>
<br>
<br>
</p>
<h1 id="Part4.2:QueryEngine">Part 4.2: Query Engine<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#Part4.2:QueryEngine" title="Link to this section"> ¶</a></h1>
<h2 id="IteratorInterface">Iterator Interface<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#IteratorInterface" title="Link to this section"> ¶</a></h2>
<p>
All of the operators that you will implement in this part inherit from the following <strong>Iterator</strong> interface.
</p>
<pre class="wiki">class Iterator {
    // All the relational operators and access methods are iterators
    // This class is the super class of all the following operator classes
public:
    virtual RC getNextTuple(void *data) = 0;

    // For each attribute in vector&lt;Attribute&gt;, name it rel.attr
    virtual void getAttributes(std::vector&lt;Attribute&gt; &amp;attrs) const = 0;

    virtual ~Iterator() = default;
};
</pre><h3 id="virtualRCgetNextTuplevoiddata">virtual RC getNextTuple(void *data)<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#virtualRCgetNextTuplevoiddata" title="Link to this section"> ¶</a></h3>
<p>
This method should set the output parameter <strong>data</strong> of the next record. The format of the <strong>data</strong> parameter, which refers to the next tuple of the operator's output, is the same as that used in previous projects. Also, null-indicators for the given attributes are always placed at the beginning of <strong>data</strong>. That is, the tuple value is a sequence of binary attribute values in which null-indicators are placed first and then each value is represented as follows: (1) For INT and REAL: use 4 bytes; (2) For VARCHAR: use 4 bytes for the length followed by the characters.
</p>
<h3 id="virtualvoidgetAttributesvectorAttributeattrs">virtual void getAttributes(vector&lt;Attribute&gt; &amp;attrs)<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#virtualvoidgetAttributesvectorAttributeattrs" title="Link to this section"> ¶</a></h3>
<p>
This method returns a vector of attributes in the intermediate relation resulted from this iterator.  That is, while the previous method returns the tuples from the operator, this method makes the associated schema information for the returned tuple stream available in the query plan. The names of the attributes in vector&lt;Attribute&gt; should be of the form relation.attribute to clearly specify the relation from which each attribute comes.
</p>
<h2 id="FilterInterface">Filter Interface<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#FilterInterface" title="Link to this section"> ¶</a></h2>
<pre class="wiki">class Filter : public Iterator {
    // Filter operator
public:
    Filter(Iterator *input,                       // Iterator of input R
           const Condition &amp;condition     // Selection condition
    );

    ~Filter() override = default;

    RC getNextTuple(void *data) override;

    // For attribute in std::vector&lt;Attribute&gt;, name it as rel.attr
    void getAttributes(std::vector&lt;Attribute&gt; &amp;attrs) const override;
};
</pre><p>
Using this iterator, you can do a selection query such as "SELECT * FROM EMP WHERE sal &gt; 100000". 
</p>
<p>
This filter class is initialized by an input iterator and a selection condition. It filters the tuples from the input iterator by applying the filter predicate <strong>condition</strong> on them. For simplicity, we assume this filter only has a single selection condition. The schema of the returned tuples should be the same as the input tuples from the iterator.
</p>
<h2 id="ProjectInterface">Project Interface<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#ProjectInterface" title="Link to this section"> ¶</a></h2>
<pre class="wiki">class Project : public Iterator {
    // Projection operator
public:
    Project(Iterator *input,                                                  // Iterator of input R
            const std::vector&lt;std::string&gt; &amp;attrNames) {};   // std::vector containing attribute names
    ~Project() override = default;

    RC getNextTuple(void *data) override;

    // For attribute in std::vector&lt;Attribute&gt;, name it as rel.attr
    void getAttributes(std::vector&lt;Attribute&gt; &amp;attrs) const override;
};
</pre><p>
This project class takes an iterator and a vector of attribute names as input. It projects out the values of the attributes in the <strong>attrNames</strong>. The schema of the returned tuples should be the attributes in attrNames, in the order of attributes in the vector.
</p>
<h2 id="BlockNested-LoopJoinInterface">Block Nested-Loop Join Interface<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#BlockNested-LoopJoinInterface" title="Link to this section"> ¶</a></h2>
<pre class="wiki">class BNLJoin : public Iterator {
    // Block nested-loop join operator
public:
    BNLJoin(Iterator *leftIn,            // Iterator of input R
            TableScan *rightIn,           // TableScan Iterator of input S
            const Condition &amp;condition,   // Join condition
            const unsigned numPages       // # of pages that can be loaded into memory,
            //   i.e., memory block size (decided by the optimizer)
    ) {};

    ~BNLJoin() override = default;

    RC getNextTuple(void *data) override;

    // For attribute in std::vector&lt;Attribute&gt;, name it as rel.attr
    void getAttributes(std::vector&lt;Attribute&gt; &amp;attrs) const override;
};
</pre><p>
The BNLJoin takes two iterators as input. The <strong>leftIn</strong> iterator works as the outer relation and the <strong>rightIn</strong> iterator is the inner relation. The <strong>rightIn</strong> is an object of the TableScan Iterator. We have already implemented the TableScan class for you, which is a wrapper on  RM_ScanIterator. The returned schema should be the attributes of tuples from leftIn concatenated with the attributes of tuples from rightIn. You don't need to remove any duplicate attributes. Note that <strong>numPages</strong> is the number of outer (left) pages that the algorithm can load into memory at once. In other words, <strong>numPages</strong> is equal to the memory block size (measured in pages) that your algorithm should utilize to make the number of loops through the inner (right) table smaller than a simple tuple-oriented join's would be (by a factor of <strong>numPages</strong>). That is, numPages is the number of buffers that can be used to as a read buffer and hash buckets. However, to make it simple, you can use these buffer pages to read records from R. You can construct an another separate in-memory hash table (e.g., std::map) to keep the records in the numPages buffer. This means std::map will take care of two things: loading tuples and hashing them. <strong>Make sure that the total number of bytes of the loaded tuples in one round does not exceed "numPages * pageSize".</strong>  You can also assume that you have one page buffer to read a page from the inner relation <strong>rightIn</strong> and one page output buffer to keep the results.
</p>
<h2 id="IndexNested-LoopJoinInterface">Index Nested-Loop Join Interface<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#IndexNested-LoopJoinInterface" title="Link to this section"> ¶</a></h2>
<pre class="wiki">class INLJoin : public Iterator {
    // Index nested-loop join operator
public:
    INLJoin(Iterator *leftIn,           // Iterator of input R
            IndexScan *rightIn,          // IndexScan Iterator of input S
            const Condition &amp;condition   // Join condition
    ) {};

    ~INLJoin() override = default;

    RC getNextTuple(void *data) override;

    // For attribute in std::vector&lt;Attribute&gt;, name it as rel.attr
    void getAttributes(std::vector&lt;Attribute&gt; &amp;attrs) const override;
};
</pre><p>
The INLJoin iterator takes two iterators as input. The <strong>leftIn</strong> iterator works as the outer relation, and the <strong>rightIn</strong> iterator is the inner relation. The <strong>rightIn</strong> is an object of IndexScan Iterator. Again, we have already implemented the IndexScan class for you, which is a wrapper on RM_IndexScanIterator. The returned schema should be the attributes of tuples from leftIn concatenated with the attributes of tuples from rightIn. You don't need to remove any duplicate attributes.
</p>
<h2 id="GraceHashJoinInterface">Grace Hash Join Interface<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#GraceHashJoinInterface" title="Link to this section"> ¶</a></h2>
<ul><li><strong> Optional: 10 extra-credit points for <em>everyone</em>. </strong>
<pre class="wiki">class GHJoin : public Iterator {
    // Grace hash join operator
public:
    GHJoin(Iterator *leftIn,               // Iterator of input R
           Iterator *rightIn,               // Iterator of input S
           const Condition &amp;condition,      // Join condition (CompOp is always EQ)
           const unsigned numPartitions     // # of partitions for each relation (decided by the optimizer)
    ) {};

    ~GHJoin() override = default;

    RC getNextTuple(void *data) override;

    // For attribute in std::vector&lt;Attribute&gt;, name it as rel.attr
    void getAttributes(std::vector&lt;Attribute&gt; &amp;attrs) const override;
};
</pre></li></ul><p>
Using this iterator you can do a join query such as "SELECT * FROM EMP, DEPT WHERE EMP.DID = DEPT.DID".
</p>
<p>
The GHJoin takes two iterators as input. It uses <strong>leftIn</strong> to iterate over the outer relation and the <strong>rightIn</strong> to iterate over the inner relation. Following is a sketch of how to implement this operator:
</p>
<blockquote>
<p>
1- In the partitioning phase, create <strong>numPartitions</strong> partitions for each relation where each partition is an rbfm file. The name of the outer relation partitions must start with the word "left" while the name of the inner relation partitions must start with the word "right". In order to avoid conflicts in the file names (in the case of multiple GHJoins in the query tree) you will have to add a suffix that uniquely identify your partitions. For example, you can have something like left_join1_XX and right_join1_XX for the first join and left_join2_XX and right_join2_XX for the second join. <strong>Note</strong>: It is NOT acceptable to load the entire relation into memory while building the partitions -- you should assume that a query optimizer has chosen the number of partitions based on the amount of memory it has decided to allow this operator to use.
</p>
</blockquote>
<p>
   
</p>
<blockquote>
<p>
2- In the probing phase, load a partition of either R or S (in fact you might want to load the smaller partition<sup>*</sup>) into memory, then build an in-memory hash table for such partition. Next, probe the corresponding partition from the other relation for matching tuples.
</p>
</blockquote>
<p>
   
</p>
<blockquote>
<p>
3- The output will be the join-tuples that must be passed to the next operator. The schema of these join-tuples should be the attributes of tuples from leftIn concatenated with the attributes of tuples from rightIn. You don't need to remove any duplicate attributes.
</p>
</blockquote>
<p>
<sup>*</sup> Note that if you load the smaller partition (to compare the sizes of the partitions you can use <strong>fileHandle.getNumberOfPages()</strong>) you may need to rearrange the output attributes if S becomes the left relation. This is NOT a requirement but a closer implementation to what happens in practice  :-).  
</p>
<h2 id="AggregateInterface">Aggregate Interface<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#AggregateInterface" title="Link to this section"> ¶</a></h2>
<ul><li><strong>Basic aggregation is Mandatory. </strong>
</li><li><strong>Group-based hash aggregation is Optional for everyone. You will get 5 extra-credit points for doing so.</strong>
</li></ul><pre class="wiki">class Aggregate : public Iterator {
    // Aggregation operator
public:
    // Mandatory
    // Basic aggregation
    Aggregate(Iterator *input,                     // Iterator of input R
              const Attribute &amp;aggAttr,            // The attribute over which we are computing an aggregate
              AggregateOp op                          // Aggregate operation
    ) {};

    // Optional for everyone: 5 extra-credit points
    // Group-based hash aggregation
    Aggregate(Iterator *input,                     // Iterator of input R
              const Attribute &amp;aggAttr,            // The attribute over which we are computing an aggregate
              const Attribute &amp;groupAttr,         // The attribute over which we are grouping the tuples
              AggregateOp op                          // Aggregate operation
    ) {};

    ~Aggregate() override = default;

    RC getNextTuple(void *data) override;

    // Please name the output attribute as aggregateOp(aggAttr)
    // E.g. Relation=rel, attribute=attr, aggregateOp=MAX
    // output attrname = "MAX(rel.attr)"
    void getAttributes(std::vector&lt;Attribute&gt; &amp;attrs) const override;
};
</pre><p>
<strong>Basic aggregation:</strong> Using the basic aggregation operator, you can execute a query such as: "SELECT MAX(sal) FROM EMP". <br>
The basic aggregate method takes an input iterator, an aggregated attribute, and an aggregate function (MIN, MAX, SUM, AVG, COUNT) as the arguments. You can assume we do the aggregation on a numeric attribute (INT or REAL). The returned value is just a single real value (4 bytes), even for the COUNT function. The schema of the (single) returned tuple should be "AggregateOp(relation.attribute)", such as "MAX(emp.sal)". Also,  null-indicators always needs to be placed at the beginning of a tuple.
</p>
<p>
<strong>Group-based hash aggregation:</strong> Using the group-based hash aggregation operator, you can execute a query such as: "SELECT city, MAX(sal) FROM EMP GROUP BY city". <br>
To implement the <em>group-by</em> feature, you need to implement the group-based hash aggregation where we add one more argument to the argument list: <strong>groupAttr</strong>, which is the group-by attribute. Unlike Grace Hash Join, you are not required to implement hash-partitioned aggregation using partitions on disk. You can assume that all of the groups' aggregation values will fit in a hash table in memory while the operation is executing. (E.g., think group by age or group by state -- where the number of groups is reasonable.) Each returned tuple should include the group-by attribute value followed by the aggregation value. The group-by attribute can be INT, REAL, or VARCHAR. The aggregated attribute can be INT or REAL. The schema of the returned tuples should be the group-by attribute and the aggregation attribute, such as "emp.city MAX(emp.sal)". Null-indicators always needs to be placed at the beginning of each tuple. <strong>5 extra-credit points</strong>
</p>
<h2 id="ImportantNote">Important Note<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#ImportantNote" title="Link to this section"> ¶</a></h2>
<p>
You must make sure that all operators which create temporary rbfm files to clean up after themselves. That is, such files must be deleted when the operator is closed. 
</p>
<h2 id="AnExample">An Example<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#AnExample" title="Link to this section"> ¶</a></h2>
<p>
Here is an example showing how to assemble the operators to form query plans.  Example: "SELECT Employee.name, Employee.age, Employee.DeptID, Department.Name FROM  Employee JOIN Department ON Employee.DeptID = Department.ID WHERE Employee.salary &gt; 50000". We are assuming for this example that the optimizer has picked the Grace Hash Join algorithm to execute the join. 
</p>
<pre class="wiki">/****** ****** ****** ****** ******
 *    TABLE SCANS
 ****** ****** ****** ****** ******/

TableScan *emp_ts = new TableScan(rm, "Employee");
TableScan *dept_ts = new TableScan(rm, "Department");

/****** ****** ****** ****** ******
 *    FILTER Employee Table
 ****** ****** ****** ****** ******/

Condition cond_f;
cond_f.lhsAttr = "Employee.Salary";
cond_f.op = GT_OP;
cond_f.bRhsIsAttr = false;
Value value;
value.type = TypeInt;
value.data = malloc(bufsize);
*(int *)value.data = 50000;
cond_f.rhsValue = value;

Filter *filter = new Filter(emp_ts, cond_f);

/****** ****** ****** ****** ******
 *    PROJECT Employee Table
 ****** ****** ****** ****** ******/

vector&lt;string&gt; attrNames;
attrNames.push_back("Employee.name");
attrNames.push_back("Employee.age");
attrNames.push_back("Employee.DeptID");

Project project(filter, attrNames);

/****** ****** ****** ****** ******
 *   GRACE HASH JOIN Employee with Dept
 ****** ****** ****** ****** ******/

Condition cond_j;
cond_j.lhsAttr = "Employee.DeptID";
cond_j.op = EQ_OP;
cond_j.bRhsIsAttr = true;
cond_j.rhsAttr = "Department.ID";

GHJoin *ghJoin = new GHJoin(project, dept_ts, cond_j, 100);

void *data = malloc(bufsize);
while(ghJoin.getNextTuple(data) != QE_EOF)
{
  printAttributes(data);
}
</pre><h2 id="CommandLineInterfaceInterpreter">Command Line Interface Interpreter<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#CommandLineInterfaceInterpreter" title="Link to this section"> ¶</a></h2>
<ul><li> <strong>Optional: There is NO implementation needed for CLI part</strong>
</li></ul><p>
Instead of having to manually assemble the operators to form query plans, as shown in the above example, we are also providing you with a Command Line Interface (CLI) that takes a SQL-like command and executes that command. This will hopefully provide a better, more flexible test environment than the manual approach presented above (e.g., assembling query plans manually, running them, and even debugging them). The CLI runs in interactive mode so that you can type commands and see their results interactively. To get more information about the CLI, please visit  <a class="wiki" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-command-line-interface">this page</a>. Note that the CLI is provided for your convenience. We will not be using the CLI to test your code.
</p>
<p>
<strong>Important Notes:</strong> 
</p>
<ol><li>In order to run the CLI on Ubuntu you might need to install this library <strong>libreadline-dev</strong>. You can run the following command to install it:
<pre class="wiki">sudo apt-get install libreadline-dev 
</pre></li></ol><ol start="2"><li>CLI uses C++11 features. You might need to use g++-4.8 to compile CLI. Please refer to <a class="ext-link" href="http://ubuntuhandbook.org/index.php/2013/08/install-gcc-4-8-via-ppa-in-ubuntu-12-04-13-04/"><span class="icon">​</span>this page</a> to install GCC 4.8 on Ubuntu. You can ignore this step if you already have a GCC with version &gt;= 4.8
</li></ol><h2 id="Appendix">Appendix<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#Appendix" title="Link to this section"> ¶</a></h2>
<p>
Below we list the APIs for the three classes used in the operators. For more detailed implementation information, please refer to the <strong>qe.h</strong> header file in the code base. Note that in the TableScan and IndexScan classes, the argument <strong>alias</strong> is used to rename the input relation. In the case of self-joins, at least one of the uses of the relations must be renamed to differentiate the two from each other in terms of attribute naming.
</p>
<pre class="wiki">struct Condition {
    string lhsAttr;             // left-hand side attribute                     
    CompOp  op;             // comparison operator                          
    bool    bRhsIsAttr;     // TRUE if right-hand side is an attribute and not a value; FALSE, otherwise
    string  rhsAttr;           // right-hand side attribute if bRhsIsAttr = TRUE
    Value   rhsValue;       // right-hand side value if bRhsIsAttr = FALSE
};
</pre><pre class="wiki">class TableScan : public Iterator
{
    TableScan(RelationManager &amp;rm, const string &amp;tableName, const char *alias = NULL);       // constructor

    void setIterator();                                                                      // Start a new iterator

    RC getNextTuple(void *data);                                                             // Return the next tuple from the iterator

    void getAttributes(vector&lt;Attribute&gt; &amp;attrs) const;                                      // Return the attributes from this iterator

    ~TableScan();                                                                            // destructor
};
</pre><pre class="wiki">class IndexScan : public Iterator
{
    IndexScan(RelationManager &amp;rm, const string &amp;tableName, const string &amp;attrName, const char *alias = NULL); // constructor

    void setIterator(void* lowKey, void* highKey, bool lowKeyInclusive, bool highKeyInclusive);                // Start a new iterator given the new compOp and value
    
    RC getNextTuple(void *data);                                                                               // Return the next tuple from the iterator

    void getAttributes(vector&lt;Attribute&gt; &amp;attrs) const;                                                        // Return the attributes from this iterator
    
    ~IndexScan();                                                                                              // destructor
};
</pre><h2 id="Testing">Testing<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#Testing" title="Link to this section"> ¶</a></h2>
<p>
Please use the provided test files included in the codebase to test your code. Note that this file will be used to grade your project partially since we also have our own private test cases. This is by no means an exhaustive test suite. Please feel free to add more cases to this, and test your code thoroughly. The test code includes provisional points for each test case. The points are subject to change if needed.
</p>
<h2 id="SubmissionInstructions">Submission Instructions<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#SubmissionInstructions" title="Link to this section"> ¶</a></h2>
<p>
The following are requirements on your submission. Points may be deducted if they are not followed.
</p>
<ul><li>Write a report to briefly describe the design and implementation of your query engine module.
</li><li>You need to submit the source code under the "rbf" ,"rm" ,"ix", "qe", and data folder. Make sure you do a "make clean" first, and do NOT include any useless files (such as binary files and data files). Your makefile should make sure the files <em>qetest_XX.cc<strong> compile and run properly. We will use our own </strong></em><strong>qetest_XX.cc</strong> files to test your module.
</li></ul><p>
 
</p>
<ul><li>Please organize your project in the following directory hierarchy: master / {rbf, rm, ix, qe, cli, data, makefile.inc, CMakelists.txt, README.md, project1_report.txt, project2_report.txt, project3_report.txt, project4_report.txt} where rbf, rm, ix, and qe folders include your source code and the makefile.
</li></ul><h2 id="GradingRubrics">Grading Rubrics<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#GradingRubrics" title="Link to this section"> ¶</a></h2>
<p>
The grading rubrics is at <a class="wiki" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4-grading">this page</a>
</p>
<h2 id="QA">Q &amp; A<a class="anchor" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#QA" title="Link to this section"> ¶</a></h2>
<ul><li><strong>Q1</strong>: For the grace hash-join and block nested loop join, can I use a std::map() as an in-memory table? <br> 
<strong>A1</strong>: Yes. You can.
</li></ul><blockquote>
<p>
<strong>Q2</strong>: For the block-nested loop join, we are supposed to use numPages buffer to read tuples from the leftIn relation. How to use the memory based on this parameter? <br>
<strong>A2</strong>: Suppose we do a BNLP for two inputs R and S, where R is the left child.   To simplify the implementation, it is acceptable to read "numPages" pages from R, then build an in-memory hash table (with additional memory) for these records.  In addition, it is also acceptable to use the getNext() API of R to read enough records to fill in *one* page, then immediately add them to the in-memory hash table.  Then we continue the process until we have read enough records for numPages pages (one page at a time).  Since the records from S are pipelined, you can join a record from S.getNext() immediately using the hash table of R.  You are required to have an output buffer.  You pause the join process whenever the output buffer is full.
</p>
</blockquote>
<ul><li><strong>Q3</strong>: What types of joins do we need to support? <br> 
<strong>A3</strong>: Based on the scope of this project, we only need you to implement equi-join on single join attribute. However, you do need to support the case that multiple records share the same join key value.
</li></ul><ul><li><strong>Q4</strong>: Do I need to read a page at a time from the right table of BNL join, since TableScan only supports a tuple-based API? <br> 
<strong>A4</strong>: For simplicity, you can read a tuple from the right table at a time and generate join tuple directly.
</li></ul><ul><li><strong>Q5</strong>: How to handle NULL values in Join,Aggregation, and GroupBy? <br> 
<strong>A5</strong>: Based on the scope of this project, you do not need to support NULL values in these operators. However, you should make sure you index does not contain NULL keys (they should be filtered out).
</li></ul></div>
          
          <div class="trac-modifiedby">
            <span><a href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4?action=diff&amp;version=12" title="Version 12 by yicongh1">Last modified</a> <a class="timeline" href="https://grape.ics.uci.edu/wiki/public/timeline?from=2019-11-20T21%3A25%3A46-08%3A00&amp;precision=second" title="See timeline at Nov 20, 2019 9:25:46 PM">7 weeks ago</a></span>
            <span class="trac-print">Last modified on Nov 20, 2019 9:25:46 PM</span>
          </div>
        
        
      </div>
      
    <div id="attachments" class="collapsed">
        <h3 class="foldable"><a id="no1" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4#no1">Attachments <span class="trac-count">(1)</span></a></h3>
        <div>
          <ul>
              <li>
    <a href="https://grape.ics.uci.edu/wiki/public/attachment/wiki/cs222-2019-fall-project4/Project4.patch" title="View attachment">Project4.patch</a><a href="https://grape.ics.uci.edu/wiki/public/raw-attachment/wiki/cs222-2019-fall-project4/Project4.patch" class="trac-rawlink" title="Download">​</a>
       (<span title="264297 bytes">258.1 KB</span>) -
      added by <em>yicongh1</em> <a class="timeline" href="https://grape.ics.uci.edu/wiki/public/timeline?from=2019-11-18T23%3A52%3A22-08%3A00&amp;precision=second" title="See timeline at Nov 18, 2019 11:52:22 PM">8 weeks ago</a>.
              </li>
          </ul>
          <p>
            Download all attachments as: <a rel="nofollow" href="https://grape.ics.uci.edu/wiki/public/zip-attachment/wiki/cs222-2019-fall-project4/">.zip</a>
          </p>
        </div>
    </div>

    </div>
    <div id="altlinks">
      <h3>Download in other formats:</h3>
      <ul>
        <li class="last first">
          <a rel="nofollow" href="https://grape.ics.uci.edu/wiki/public/wiki/cs222-2019-fall-project4?format=txt">Plain Text</a>
        </li>
      </ul>
    </div>
    </div>
    <div id="footer" lang="en" xml:lang="en"><hr>
      <a id="tracpowered" href="http://trac.edgewall.org/"><img src="./cs222-2019-fall-project4 – Public_files/trac_logo_mini.png" height="30" width="107" alt="Trac Powered"></a>
      <p class="left">Powered by <a href="https://grape.ics.uci.edu/wiki/public/about"><strong>Trac 1.0.13</strong></a><br>
        By <a href="http://www.edgewall.org/">Edgewall Software</a>.</p>
      <p class="right">Visit the Trac open source project at<br><a href="http://trac.edgewall.org/">http://trac.edgewall.org/</a></p>
    </div>
  
</body></html>